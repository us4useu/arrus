#ifndef ARRUS_CORE_API_OPS_US4R_H
#define ARRUS_CORE_API_OPS_US4R_H

#include <utility>

#include "DigitalDownConversion.h"
#include "TxRxSequence.h"
#include "arrus/core/api/framework/DataBufferSpec.h"

namespace arrus::ops::us4r {


class SchemeBuilder;

/**
 * A scheme to be executed within the session.
 */
class Scheme {
public:
    /**
     * How the scheme should be executed on the us4r-lite device.
     *
     * This enum value determines the source of the signal trigger
     * (i.e. whether the signal is triggered by us4oem modules or
     * host PC).
     */
    enum class WorkMode {
        /** Trigger generated by us4r, error on overflow. */
        ASYNC,
        /** Trigger generated by us4r, us4r waits on overflow */
        SYNC,
        /** Trigger generated by host, no error on overflow. DEPRECATED: will be replaced in the future by MANUAL mode */
        HOST,
        /** New data acquisition and processing is manually triggered by user. The systems stops per sequence execution. */
        MANUAL,
        /** New data acquisition and processing is manually triggered by user. The systems stops per TX/RX execution. */
        MANUAL_OP
    };


    /**
     * Returns true if the work mode is MANUAL (MANUAL per sequence or MANUAL_TX_RX (per TX/RX).
     */
    static bool isWorkModeManual(WorkMode workMode) {
        return workMode == WorkMode::MANUAL || workMode == WorkMode::MANUAL_OP;
    }

    /**
     * Returns true if the work mode is MANUAL (MANUAL per sequence or MANUAL_TX_RX (per TX/RX).
     */
    bool isWorkModeManual() const {
        return isWorkModeManual(this->getWorkMode());
    }

    /**
     * TODO(0.12.0) Deprecated: please use Scheme::create instead
     */
    ARRUS_CPP_EXPORT
    Scheme(TxRxSequence txRxSequence, uint16 rxBufferSize, const framework::DataBufferSpec &outputBuffer,
           WorkMode workMode, std::optional<DigitalDownConversion> ddc,
           const std::vector<arrus::framework::NdArray> &constants);

    /**
     * Scheme constructor. This scheme turns off hardware IQ demodulator.
     * TODO(0.12.0) Deprecated: please use Scheme::create instead
     *
     * @param txRxSequence tx/rx sequence to perform
     * @param rxBufferSize the size of the data acquisition buffer in the memory of the Us4R device
     *   (a single element of the buffer is an output of a single tx/rx sequence execution)
     * @param outputBuffer output buffer specification
     * @param workMode scheme work mode
     */
    ARRUS_CPP_EXPORT
    Scheme(TxRxSequence txRxSequence, uint16 rxBufferSize, const framework::DataBufferSpec &outputBuffer,
           WorkMode workMode)
        :Scheme(std::move(txRxSequence), rxBufferSize, outputBuffer, workMode, std::nullopt, {}) {}

    /**
     * Scheme constructor. This scheme turns on hardware IQ demodulator (sees digital down conversion parameter).
     *
     * TODO(0.12.0) Deprecated: please use Scheme::create instead
     *
     * @param txRxSequence tx/rx sequence to perform
     * @param rxBufferSize the size of the data acquisition buffer in the memory of the Us4R device
     *   (a single element of the buffer is an output of a single tx/rx sequence execution)
     * @param outputBuffer output buffer specification
     * @param workMode scheme work mode
     * @param digitalDownConversion DDC parameters
     */
    ARRUS_CPP_EXPORT
    Scheme(TxRxSequence txRxSequence, uint16 rxBufferSize, const framework::DataBufferSpec &outputBuffer,
           WorkMode workMode, DigitalDownConversion ddc)
        : Scheme(std::move(txRxSequence), rxBufferSize, outputBuffer, workMode, std::move(ddc), {}) {}


    /**
     * TODO(0.12.0) Deprecated: please use Scheme::create instead
     */
    ARRUS_CPP_EXPORT
    Scheme(TxRxSequence txRxSequence, uint16 rxBufferSize, const framework::DataBufferSpec &outputBuffer,
           WorkMode workMode, const std::vector<framework::NdArray> &constants)
        : Scheme(std::move(txRxSequence), rxBufferSize, outputBuffer, workMode, std::nullopt, constants) {}

    ARRUS_CPP_EXPORT
    Scheme(const Scheme &o);
    ARRUS_CPP_EXPORT
    Scheme(Scheme &&o) noexcept;
    ARRUS_CPP_EXPORT
    virtual ~Scheme();
    Scheme& operator=(const Scheme &o);
    Scheme& operator=(Scheme &&o) noexcept;

    /**
     * TODO(0.12.0) Deprecated: please use getTxRxSequence(int ordinal) instead
     */
     ARRUS_CPP_EXPORT
    const TxRxSequence &getTxRxSequence() const;
    ARRUS_CPP_EXPORT
    const TxRxSequence &getTxRxSequence(size_t ordinal) const;
    ARRUS_CPP_EXPORT
    const std::vector<TxRxSequence> &getTxRxSequences() const;
    ARRUS_CPP_EXPORT
    uint16 getRxBufferSize() const;
    ARRUS_CPP_EXPORT
    const framework::DataBufferSpec &getOutputBuffer() const;
    ARRUS_CPP_EXPORT
    WorkMode getWorkMode() const;
    ARRUS_CPP_EXPORT
    const std::optional<DigitalDownConversion> &getDigitalDownConversion() const;
    ARRUS_CPP_EXPORT
    const std::vector<arrus::framework::NdArray> &getConstants() const;

private:
    friend class SchemeBuilder;
    ARRUS_CPP_EXPORT
    Scheme();
    class Impl;
    UniqueHandle<Impl> impl;
};

class SchemeBuilder {
public:
    ARRUS_CPP_EXPORT
    SchemeBuilder() = default;
    ARRUS_CPP_EXPORT
    SchemeBuilder& addSequence(TxRxSequence sequence);
   ARRUS_CPP_EXPORT
    SchemeBuilder& withOutputBufferDefinition(framework::DataBufferSpec spec);
   ARRUS_CPP_EXPORT
    SchemeBuilder& withRxBufferSize(uint16 rxBufferSize);
    ARRUS_CPP_EXPORT
    SchemeBuilder& withWorkMode(Scheme::WorkMode mode);
    ARRUS_CPP_EXPORT
    SchemeBuilder& withDigitalDownConversion(DigitalDownConversion ddc);
    // TODO support constants

    ARRUS_CPP_EXPORT
    Scheme build();
private:
    Scheme scheme;
};

}// namespace arrus::ops::us4r

#endif//ARRUS_CORE_API_OPS_US4R_H
